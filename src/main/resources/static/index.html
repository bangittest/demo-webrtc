<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>WebRTC Stream/Viewer</title>
    <style>
        video { width:300px; height:200px; background:#ddd; margin:5px; }
        .debug { font-family: monospace; font-size: 12px; margin: 10px 0; }
    </style>
</head>
<body>
<h1>Ch·ªçn vai tr√≤</h1>
<select id="role">
    <option value="streamer">Streamer</option>
    <option value="viewer">Viewer</option>
</select>
<button id="startBtn">B·∫Øt ƒë·∫ßu</button>

<div><h3>Local video</h3><video id="localVideo" autoplay playsinline muted></video></div>
<div><h3>Remote video</h3><video id="remoteVideo" autoplay playsinline controls></video></div>
<div id="videos"></div>
<div class="debug">
    <div>Connection State: <span id="connState">-</span></div>
    <div>ICE State: <span id="iceState">-</span></div>
    <div>Remote Tracks: <span id="trackCount">0</span></div>
</div>

<script>
    const localVideo = document.getElementById('localVideo');
    const remoteVideo = document.getElementById('remoteVideo');
    const connState = document.getElementById('connState');
    const iceState = document.getElementById('iceState');
    const trackCount = document.getElementById('trackCount');

    // Debug video events
    remoteVideo.addEventListener('loadstart', () => console.log("üì∫ Video: loadstart"));
    remoteVideo.addEventListener('loadedmetadata', () => console.log("üì∫ Video: loadedmetadata", remoteVideo.videoWidth + "x" + remoteVideo.videoHeight));
    remoteVideo.addEventListener('loadeddata', () => console.log("üì∫ Video: loadeddata"));
    remoteVideo.addEventListener('canplay', () => console.log("üì∫ Video: canplay"));
    remoteVideo.addEventListener('playing', () => console.log("üì∫ Video: playing"));
    remoteVideo.addEventListener('error', (e) => console.error("üì∫ Video error:", e));

    let role, pc, ws, localStream;
    let isRemoteSet = false;
    const candidateQueue = [];
    const peerConnections = {};
    const videos = {};
    document.getElementById('startBtn').onclick = () => {
        role = document.getElementById('role').value;
        console.log("Vai tr√≤:", role);
        start();
    };

    function updateDebugInfo() {
        if (pc) {
            connState.textContent = pc.connectionState;
            iceState.textContent = pc.iceConnectionState;

            if (remoteVideo.srcObject) {
                const tracks = remoteVideo.srcObject.getTracks();
                trackCount.textContent = tracks.length;

                // Log chi ti·∫øt v·ªÅ video element
                console.log("üì° Debug Info:");
                console.log("  - Connection:", pc.connectionState);
                console.log("  - ICE:", pc.iceConnectionState);
                console.log("  - srcObject:", !!remoteVideo.srcObject);
                console.log("  - tracks:", tracks.map(t => `${t.kind}:${t.readyState}`));
                console.log("  - videoWidth:", remoteVideo.videoWidth);
                console.log("  - videoHeight:", remoteVideo.videoHeight);
                console.log("  - readyState:", remoteVideo.readyState);
                console.log("  - paused:", remoteVideo.paused);

                // Force play n·∫øu b·ªã pause
                if (remoteVideo.paused && remoteVideo.readyState >= 2) {
                    console.log("üì∫ Attempting to play video...");
                    remoteVideo.play().catch(e => console.error("Play failed:", e));
                }
            }
        }
    }

    function start() {
        ws = new WebSocket('wss://192.168.0.103:8443/socket');
        pc = new RTCPeerConnection({
            iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
        });

        // Debug connection states
        pc.onconnectionstatechange = () => {
            console.log("üì° Connection state:", pc.connectionState);
            updateDebugInfo();
        };

        pc.oniceconnectionstatechange = () => {
            console.log("üì° ICE connection state:", pc.iceConnectionState);
            updateDebugInfo();
        };

        // ICE candidate handling
        pc.onicecandidate = e => {
            if (e.candidate) {
                console.log("üì° Sending ICE candidate:", e.candidate);
                send({ event: 'candidate', data: e.candidate });
            } else {
                console.log("üì° ICE gathering complete");
            }
        };

        // FIX: X·ª≠ l√Ω remote tracks ƒë√∫ng c√°ch - kh√¥ng ghi ƒë√® srcObject
        let remoteStream = null;

        pc.ontrack = e => {
            console.log("üì° Remote track event:", e.track.kind, "ID:", e.track.id);

            // T·∫°o ho·∫∑c s·ª≠ d·ª•ng remoteStream hi·ªán t·∫°i
            if (!remoteStream) {
                if (e.streams && e.streams[0]) {
                    remoteStream = e.streams[0];
                    console.log("üì° Using stream from event");
                } else {
                    remoteStream = new MediaStream();
                    console.log("üì° Created new MediaStream");
                }
                remoteVideo.srcObject = remoteStream;
            }

            // N·∫øu kh√¥ng c√≥ stream trong event, th√™m track th·ªß c√¥ng
            if (!e.streams || !e.streams[0]) {
                // Ki·ªÉm tra track ƒë√£ t·ªìn t·∫°i ch∆∞a
                const existingTrack = remoteStream.getTracks()
                    .find(t => t.kind === e.track.kind);

                if (!existingTrack) {
                    console.log("üì° Adding track to stream:", e.track.kind);
                    remoteStream.addTrack(e.track);
                } else {
                    console.log("üì° Replacing existing track:", e.track.kind);
                    remoteStream.removeTrack(existingTrack);
                    remoteStream.addTrack(e.track);
                }
            }

            // Log th√¥ng tin stream
            console.log("üì° Current stream tracks:", remoteStream.getTracks().map(t => t.kind));
            updateDebugInfo();
        };

        ws.onopen = () => {
            console.log("üì° WebSocket connected");
            send({ event: 'join', data: role });

            if (role === 'streamer') {
                navigator.mediaDevices.getUserMedia({
                    video: { width: 640, height: 480 },
                    audio: true
                })
                    .then(stream => {
                        localStream = stream;
                        localVideo.srcObject = stream;

                        // Th√™m tracks v√†o peer connection
                        stream.getTracks().forEach(track => {
                            console.log("üì° Adding local track:", track.kind);
                            pc.addTrack(track, stream);
                        });

                        return pc.createOffer();
                    })
                    .then(offer => {
                        console.log("üì° Created offer");
                        return pc.setLocalDescription(offer);
                    })
                    .then(() => {
                        console.log("üì° Local description set, sending offer");
                        send({ event: 'offer', data: pc.localDescription });
                    })
                    .catch(err => {
                        console.error("‚ùå Streamer setup error:", err);
                    });
            }
        };

        ws.onmessage = msg => {
            const m = JSON.parse(msg.data);
            console.log('üì® Message received:', m.event, m.data ? '(with data)' : '(no data)');

            switch (m.event) {
                case 'offer':
                    if (role === 'viewer') handleOffer(m.data);
                    break;
                case 'answer':
                    if (role === 'streamer') handleAnswer(m.data);
                    break;
                case 'candidate':
                    console.log('üßä Received ICE candidate for role:', role);
                    handleCandidate(m.data);
                    break;



                case 'request-offer':
                    if (role === 'streamer') {
                        // T·∫†O L·∫†I OFFER CHO VIEWER M·ªöI
                        pc.createOffer()
                            .then(offer => pc.setLocalDescription(offer))
                            .then(() => {
                                send({
                                    event: 'offer',
                                    data: pc.localDescription,
                                    targetViewer: m.viewerId // Optional: G·ª≠i ƒë√≠ch danh
                                });
                            })
                            .catch(err => console.error('‚ùå Error creating offer:', err));
                    }
                    break;
            }
        };

        ws.onerror = err => console.error("‚ùå WebSocket error:", err);
        ws.onclose = () => console.log("üì° WebSocket closed");

    }

    function handleOffer(offer) {
        console.log("üì° Handling offer");
        const desc = (typeof offer === 'string') ? JSON.parse(offer) : offer;

        pc.setRemoteDescription(new RTCSessionDescription(desc))
            .then(() => {
                console.log("üì° Remote description set");
                isRemoteSet = true;

                // X·ª≠ l√Ω candidates trong queue
                console.log("üì° Processing", candidateQueue.length, "queued candidates");
                candidateQueue.forEach(cand => {
                    pc.addIceCandidate(cand)
                        .then(() => console.log("üì° Queued candidate added"))
                        .catch(err => console.error("‚ùå Queued candidate error:", err));
                });
                candidateQueue.length = 0;

                return pc.createAnswer();
            })
            .then(answer => {
                console.log("üì° Created answer");
                return pc.setLocalDescription(answer);
            })
            .then(() => {
                console.log("üì° Local description (answer) set, sending");
                send({ event: 'answer', data: pc.localDescription });

                // Ki·ªÉm tra connection state sau 3 gi√¢y
                setTimeout(() => {
                    console.log("üì° Connection check after 3s:");
                    updateDebugInfo();

                    if (pc.iceConnectionState === 'failed' || pc.iceConnectionState === 'disconnected') {
                        console.log("‚ùå ICE connection failed - possible firewall/NAT issue");
                    }
                }, 3000);
            })
            .catch(err => console.error("‚ùå handleOffer error:", err));
    }

    function handleAnswer(answer) {
        console.log("üì° Handling answer");
        pc.setRemoteDescription(new RTCSessionDescription(answer))
            .then(() => {
                console.log("üì° Answer set as remote description");
                isRemoteSet = true;
            })
            .catch(err => console.error("‚ùå handleAnswer error:", err));
    }

    function handleCandidate(candidate) {
        console.log("üì° Handling ICE candidate:", candidate.candidate?.substring(0, 50) + "...");
        const ice = new RTCIceCandidate(candidate);

        if (isRemoteSet && pc.remoteDescription) {
            pc.addIceCandidate(ice)
                .then(() => {
                    console.log("üì° ICE candidate added successfully");
                    // Update debug info sau khi th√™m candidate
                    setTimeout(updateDebugInfo, 100);
                })
                .catch(err => console.error("‚ùå ICE candidate error:", err));
        } else {
            console.log("üì° Candidate queued (remote not ready)");
            candidateQueue.push(ice);
        }
    }

    function send(message) {
        if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ ...message, role }));
        } else {
            console.error("‚ùå WebSocket not ready");
        }
    }

    // Cleanup khi ƒë√≥ng trang
    window.addEventListener('beforeunload', () => {
        if (localStream) {
            localStream.getTracks().forEach(track => track.stop());
        }
        if (pc) pc.close();
        if (ws) ws.close();
    });
</script>
</body>
</html>
